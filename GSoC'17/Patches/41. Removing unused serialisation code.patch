From b021353dd62c3d8c9ee0281753b88f6304a2514d Mon Sep 17 00:00:00 2001
From: Varun Dhall <varun.dhall@studentpartner.com>
Date: Mon, 14 Aug 2017 22:08:36 +0530
Subject: [PATCH] Removing unused serialisation code

Change-Id: Id31c8de69043d393f005f83d5c7eba878af5119c
Reviewed-on: https://gerrit.libreoffice.org/41149
Tested-by: Jenkins <ci@libreoffice.org>
Reviewed-by: Michael Stahl <mstahl@redhat.com>
---
 include/svl/itempool.hxx        |   19 -
 include/svl/itemset.hxx         |    5 -
 include/svl/poolitem.hxx        |    2 -
 include/svx/pageitem.hxx        |    5 -
 include/svx/xflasit.hxx         |    1 -
 include/svx/xlnasit.hxx         |    1 -
 sc/inc/patattr.hxx              |    2 -
 sc/source/core/data/patattr.cxx |   47 --
 svl/source/inc/poolio.hxx       |   11 -
 svl/source/items/itempool.cxx   |   15 -
 svl/source/items/itemset.cxx    |  135 -----
 svl/source/items/poolio.cxx     | 1094 ---------------------------------------
 svl/source/items/sitem.cxx      |    7 -
 svx/source/items/pageitem.cxx   |   49 --
 svx/source/xoutdev/xattr.cxx    |   18 -
 15 files changed, 1411 deletions(-)

diff --git a/include/svl/itempool.hxx b/include/svl/itempool.hxx
index 8228848..14051f6 100644
--- a/include/svl/itempool.hxx
+++ b/include/svl/itempool.hxx
@@ -151,25 +151,10 @@ public:
     void                            Remove( const SfxPoolItem& );
     const SfxPoolItem&              GetDefaultItem( sal_uInt16 nWhich ) const;
 
-    const SfxPoolItem*              LoadItem( SvStream &rStream,
-                                              const SfxItemPool *pRefPool );
-    bool                            StoreItem( SvStream &rStream,
-                                               const SfxPoolItem &rItem,
-                                               bool bDirect ) const;
-
     sal_uInt32                      GetSurrogate(const SfxPoolItem *) const;
     const SfxPoolItem *             GetItem2(sal_uInt16 nWhich, sal_uInt32 nSurrogate) const;
     const SfxPoolItem *             GetItem2Default(sal_uInt16 nWhich) const;
     sal_uInt32                      GetItemCount2(sal_uInt16 nWhich) const;
-    const SfxPoolItem*              LoadSurrogate(SvStream& rStream,
-                                            sal_uInt16 &rWhich, sal_uInt16 nSlotId,
-                                            const SfxItemPool* pRefPool = nullptr );
-    bool                            StoreSurrogate(SvStream& rStream,
-                                            const SfxPoolItem *pItem ) const;
-
-    SvStream &                      Load(SvStream &);
-    SvStream &                      Store(SvStream &) const;
-    void                            LoadCompleted();
 
     sal_uInt16                      GetFirstWhich() const;
     sal_uInt16                      GetLastWhich() const;
@@ -191,12 +176,8 @@ public:
     sal_uInt16                      GetTrueWhich( sal_uInt16 nSlot, bool bDeep = true ) const;
     sal_uInt16                      GetTrueSlotId( sal_uInt16 nWhich ) const;
 
-    void                            SetVersionMap( sal_uInt16 nVer,
-                                                   sal_uInt16 nOldStart, sal_uInt16 nOldEnd,
-                                                   const sal_uInt16 *pWhichIdTab );
     sal_uInt16                      GetNewWhich( sal_uInt16 nOldWhich ) const;
     void                            SetFileFormatVersion( sal_uInt16 nFileFormatVersion );
-    bool                            IsCurrentVersionLoading() const;
 
     static bool                     IsWhich(sal_uInt16 nId) {
                                         return nId && nId <= SFX_WHICH_MAX; }
diff --git a/include/svl/itemset.hxx b/include/svl/itemset.hxx
index 95953dd..89c6149 100644
--- a/include/svl/itemset.hxx
+++ b/include/svl/itemset.hxx
@@ -202,9 +202,6 @@ public:
     void                        MergeRange( sal_uInt16 nFrom, sal_uInt16 nTo );
     const SfxItemSet*           GetParent() const { return m_pParent; }
 
-    void                        Load( SvStream & );
-    void                        Store( SvStream &, bool bDirect = false ) const;
-
     bool                        operator==(const SfxItemSet &) const;
 
     /** Compare possibly ignoring SfxItemPool pointer.
@@ -220,8 +217,6 @@ public:
      */
     bool                        Equals(const SfxItemSet &, bool bComparePool) const;
 
-    sal_Int32                   getHash() const;
-    OString                     stringify() const;
     void dumpAsXml(struct _xmlTextWriter* pWriter) const;
 };
 
diff --git a/include/svl/poolitem.hxx b/include/svl/poolitem.hxx
index 5e07105..2977ae7 100644
--- a/include/svl/poolitem.hxx
+++ b/include/svl/poolitem.hxx
@@ -287,8 +287,6 @@ public:
 
     // create a copy of itself
     virtual SfxPoolItem*    Clone( SfxItemPool *pPool = nullptr ) const override = 0;
-    virtual SfxPoolItem*    Create(SvStream &, sal_uInt16 nVersion) const override = 0;
-    virtual SvStream&       Store(SvStream &, sal_uInt16 nVer) const override;
 
     const SfxItemSet&       GetItemSet() const
                             { return *pSet; }
diff --git a/include/svx/pageitem.hxx b/include/svx/pageitem.hxx
index e83d81b..32633d5 100644
--- a/include/svx/pageitem.hxx
+++ b/include/svx/pageitem.hxx
@@ -75,8 +75,6 @@ public:
 
     virtual bool             QueryValue( css::uno::Any& rVal, sal_uInt8 nMemberId = 0 ) const override;
     virtual bool             PutValue( const css::uno::Any& rVal, sal_uInt8 nMemberId ) override;
-    virtual SfxPoolItem*     Create( SvStream&, sal_uInt16 ) const override;
-    virtual SvStream&        Store( SvStream& , sal_uInt16 nItemVersion ) const override;
 
     // orientation
     SvxPageUsage    GetPageUsage() const                { return eUse;       }
@@ -111,9 +109,6 @@ public:
                                   MapUnit eCoreMetric,
                                   MapUnit ePresMetric,
                                   OUString &rText, const IntlWrapper& ) const override;
-
-    virtual SfxPoolItem*    Create( SvStream&, sal_uInt16 nVersion ) const override;
-    virtual SvStream&       Store( SvStream&, sal_uInt16 nItemVersion ) const override;
 };
 
 
diff --git a/include/svx/xflasit.hxx b/include/svx/xflasit.hxx
index 62419e2..f6c62ae 100644
--- a/include/svx/xflasit.hxx
+++ b/include/svx/xflasit.hxx
@@ -37,7 +37,6 @@ public:
                             XFillAttrSetItem(const XFillAttrSetItem& rAttr,
                                              SfxItemPool* pItemPool);
     virtual SfxPoolItem*    Clone( SfxItemPool* pToPool = nullptr ) const override;
-    virtual SfxPoolItem*    Create( SvStream& rStream, sal_uInt16 nVersion ) const override;
 };
 
 #endif
diff --git a/include/svx/xlnasit.hxx b/include/svx/xlnasit.hxx
index 1643c22..76e176f 100644
--- a/include/svx/xlnasit.hxx
+++ b/include/svx/xlnasit.hxx
@@ -37,7 +37,6 @@ public:
                             XLineAttrSetItem(const XLineAttrSetItem& rAttr,
                                              SfxItemPool* pItemPool);
     virtual SfxPoolItem*    Clone( SfxItemPool* pToPool = nullptr ) const override;
-    virtual SfxPoolItem*    Create( SvStream& rStream, sal_uInt16 nVersion ) const override;
 };
 
 #endif
diff --git a/sc/inc/patattr.hxx b/sc/inc/patattr.hxx
index 964b4a4..422fa5b 100644
--- a/sc/inc/patattr.hxx
+++ b/sc/inc/patattr.hxx
@@ -64,8 +64,6 @@ public:
                             virtual ~ScPatternAttr() override;
 
     virtual SfxPoolItem*    Clone( SfxItemPool *pPool = nullptr ) const override;
-    virtual SfxPoolItem*    Create(SvStream& rStream, sal_uInt16 nVersion) const override;
-    virtual SvStream&       Store(SvStream& rStream, sal_uInt16 nItemVersion) const override;
 
     virtual bool            operator==(const SfxPoolItem& rCmp) const override;
 
diff --git a/sc/source/core/data/patattr.cxx b/sc/source/core/data/patattr.cxx
index cddd652..57c21c0 100644
--- a/sc/source/core/data/patattr.cxx
+++ b/sc/source/core/data/patattr.cxx
@@ -143,53 +143,6 @@ bool ScPatternAttr::operator==( const SfxPoolItem& rCmp ) const
              StrCmp( GetStyleName(), static_cast<const ScPatternAttr&>(rCmp).GetStyleName() ) );
 }
 
-SfxPoolItem* ScPatternAttr::Create( SvStream& rStream, sal_uInt16 /* nVersion */ ) const
-{
-    OUString* pStr;
-    bool    bHasStyle;
-
-    rStream.ReadCharAsBool( bHasStyle );
-
-    if ( bHasStyle )
-    {
-        short   eFamDummy;
-        pStr = new OUString;
-        *pStr = rStream.ReadUniOrByteString( rStream.GetStreamCharSet() );
-        rStream.ReadInt16( eFamDummy ); // due to old data format
-    }
-    else
-        pStr = new OUString( ScGlobal::GetRscString(STR_STYLENAME_STANDARD) );
-
-    auto pNewSet = o3tl::make_unique<SfxItemSet>( *GetItemSet().GetPool(),
-                                       svl::Items<ATTR_PATTERN_START, ATTR_PATTERN_END>{} );
-    pNewSet->Load( rStream );
-
-    ScPatternAttr* pPattern = new ScPatternAttr( std::move(pNewSet) );
-
-    pPattern->pName.reset( pStr );
-
-    return pPattern;
-}
-
-SvStream& ScPatternAttr::Store(SvStream& rStream, sal_uInt16 /* nItemVersion */) const
-{
-    rStream.WriteBool( true );
-
-    if ( pStyle )
-        rStream.WriteUniOrByteString( pStyle->GetName(), rStream.GetStreamCharSet() );
-    else if ( pName )                   // when style is/was deleted
-        rStream.WriteUniOrByteString( *pName, rStream.GetStreamCharSet() );
-    else
-        rStream.WriteUniOrByteString( ScGlobal::GetRscString(STR_STYLENAME_STANDARD),
-                                    rStream.GetStreamCharSet() );
-
-    rStream.WriteInt16( (sal_uInt16) SfxStyleFamily::Para );  // due to old data format
-
-    GetItemSet().Store( rStream );
-
-    return rStream;
-}
-
 SvxCellOrientation ScPatternAttr::GetCellOrientation( const SfxItemSet& rItemSet, const SfxItemSet* pCondSet )
 {
     SvxCellOrientation eOrient = SVX_ORIENTATION_STANDARD;
diff --git a/svl/source/inc/poolio.hxx b/svl/source/inc/poolio.hxx
index 22be488..373a45b 100644
--- a/svl/source/inc/poolio.hxx
+++ b/svl/source/inc/poolio.hxx
@@ -103,18 +103,14 @@ struct SfxItemPool_Impl
     SfxItemPool*                    mpMaster;
     SfxItemPool*                    mpSecondary;
     sal_uInt16*                     mpPoolRanges;
-    std::deque< SfxPoolVersion_ImplPtr > aVersions;
     sal_uInt16                      mnStart;
     sal_uInt16                      mnEnd;
     sal_uInt16                      mnFileFormatVersion;
     sal_uInt16                      nVersion;
-    sal_uInt16                      nLoadingVersion;
     sal_uInt16                      nInitRefCount; // 1, during load, may be 2
     sal_uInt16                      nVerStart, nVerEnd; // WhichRange in versions
-    sal_uInt8                       nMajorVer, nMinorVer; // The Pool itself
     MapUnit                         eDefMetric;
     bool                            bInSetItem;
-    bool                            bStreaming; // in Load() or Store()
     bool                            mbPersistentRefCounts;
 
     SfxItemPool_Impl( SfxItemPool* pMaster, const OUString& rName, sal_uInt16 nStart, sal_uInt16 nEnd )
@@ -129,15 +125,11 @@ struct SfxItemPool_Impl
         , mnEnd(nEnd)
         , mnFileFormatVersion(0)
         , nVersion(0)
-        , nLoadingVersion(0)
         , nInitRefCount(0)
         , nVerStart(0)
         , nVerEnd(0)
-        , nMajorVer(0)
-        , nMinorVer(0)
         , eDefMetric(MapUnit::MapCM)
         , bInSetItem(false)
-        , bStreaming(false)
         , mbPersistentRefCounts(false)
     {
         DBG_ASSERT(mnStart, "Start-Which-Id must be greater 0" );
@@ -159,9 +151,6 @@ struct SfxItemPool_Impl
         mpPoolRanges = nullptr;
     }
 
-    void readTheItems(SvStream & rStream, sal_uInt32 nCount, sal_uInt16 nVersion,
-                      SfxPoolItem const * pDefItem, SfxPoolItemArray_Impl ** pArr);
-
     // unit testing
     friend class PoolItemTest;
     static SfxItemPool_Impl *GetImpl(SfxItemPool const *pPool) { return pPool->pImpl.get(); }
diff --git a/svl/source/items/itempool.cxx b/svl/source/items/itempool.cxx
index f39b2dc..98983b6 100644
--- a/svl/source/items/itempool.cxx
+++ b/svl/source/items/itempool.cxx
@@ -178,11 +178,7 @@ SfxItemPool::SfxItemPool
 {
     pImpl->eDefMetric = MapUnit::MapTwip;
     pImpl->nVersion = 0;
-    pImpl->bStreaming = false;
-    pImpl->nLoadingVersion = 0;
     pImpl->nInitRefCount = 1;
-    pImpl->nVerStart = pImpl->mnStart;
-    pImpl->nVerEnd = pImpl->mnEnd;
     pImpl->bInSetItem = false;
     pImpl->mbPersistentRefCounts = bLoadRefCounts;
 
@@ -210,11 +206,7 @@ SfxItemPool::SfxItemPool
 {
     pImpl->eDefMetric = rPool.pImpl->eDefMetric;
     pImpl->nVersion = rPool.pImpl->nVersion;
-    pImpl->bStreaming = false;
-    pImpl->nLoadingVersion = 0;
     pImpl->nInitRefCount = 1;
-    pImpl->nVerStart = rPool.pImpl->nVerStart;
-    pImpl->nVerEnd = rPool.pImpl->nVerEnd;
     pImpl->bInSetItem = false;
     pImpl->mbPersistentRefCounts = rPool.pImpl->mbPersistentRefCounts;
 
@@ -241,13 +233,6 @@ SfxItemPool::SfxItemPool
             pImpl->maPoolDefaults[n]->SetKind(SfxItemKind::PoolDefault);
         }
 
-    // Copy Version map
-    for (std::shared_ptr<SfxPoolVersion_Impl>& pOld : rPool.pImpl->aVersions)
-    {
-        SfxPoolVersion_ImplPtr pNew = std::make_shared<SfxPoolVersion_Impl>( *pOld );
-        pImpl->aVersions.push_back( pNew );
-    }
-
     // Repair linkage
     if ( rPool.pImpl->mpSecondary )
         SetSecondaryPool( rPool.pImpl->mpSecondary->Clone() );
diff --git a/svl/source/items/itemset.cxx b/svl/source/items/itemset.cxx
index 19e3f7a..3b7efdc 100644
--- a/svl/source/items/itemset.cxx
+++ b/svl/source/items/itemset.cxx
@@ -1323,127 +1323,6 @@ sal_uInt16 SfxItemSet::GetWhichByPos( sal_uInt16 nPos ) const
     return 0;
 }
 
-/**
- * Saves the SfxItemSet instance to the supplied Stream.
- * The surrogates as well as the ones with 'bDirect == true' are saved
- * to the stream in the following way:
- *
- *  sal_uInt16  ... Count of the set Items
- *  Count*  m_pPool->StoreItem()
- *
- *  @see SfxItemPool::StoreItem() const
- *  @see SfxItemSet::Load(SvStream&,bool,const SfxItemPool*)
- */
-void SfxItemSet::Store
-(
-    SvStream&   rStream,        // Target stream for normal Items
-    bool        bDirect         /* true: Save Items directly
-                                   false: Surrogates */
-)   const
-{
-    assert(m_pPool);
-
-    // Remember position of the count (to be able to correct it, if need be)
-    sal_uLong nCountPos = rStream.Tell();
-    rStream.WriteUInt16( m_nCount );
-
-    // If there's nothing to save, don't construct an ItemIter
-    if (m_nCount)
-    {
-        // Keep record of how many Items are really saved
-        sal_uInt16 nWrittenCount = 0; // Count of Items streamed in 'rStream'
-
-        // Iterate over all set Items
-        SfxItemIter aIter(*this);
-        for ( const SfxPoolItem *pItem = aIter.FirstItem();
-              pItem;
-              pItem = aIter.NextItem() )
-        {
-            // Let Items (if need be as a Surrogate) be saved via Pool
-            SAL_WARN_IF(IsInvalidItem(pItem), "svl.items", "can't store invalid items");
-            if ( !IsInvalidItem(pItem) &&
-                 m_pPool->StoreItem( rStream, *pItem, bDirect ) )
-                // Item was streamed in 'rStream'
-                ++nWrittenCount;
-        }
-
-        // Fewer written than read (e.g. old format)
-        if (nWrittenCount != m_nCount)
-        {
-            // Store real count in the stream
-            sal_uLong nPos = rStream.Tell();
-            rStream.Seek( nCountPos );
-            rStream.WriteUInt16( nWrittenCount );
-            rStream.Seek( nPos );
-        }
-    }
-}
-
-/**
- * This method loads an SfxItemSet from a stream.
- * If the SfxItemPool was loaded without RefCounts the loaded Item
- * references are counted, else we assume the they were accounted for
- * when loading the SfxItemPool.
- *
- * @see SfxItemSet::Store(Stream&,bool) const
- */
-void SfxItemSet::Load
-(
-    SvStream&           rStream    //  Stream we're loading from
-)
-{
-    assert(m_pPool);
-
-    // Resolve Surrogates with ItemSet's Pool
-    const SfxItemPool *pRefPool = m_pPool;
-
-    // Load Item count and as many Items
-    sal_uInt16 nCount = 0;
-    rStream.ReadUInt16( nCount );
-
-    const size_t nMinRecordSize = sizeof(sal_uInt16) * 2;
-    const size_t nMaxRecords = rStream.remainingSize() / nMinRecordSize;
-    if (nCount > nMaxRecords)
-    {
-        SAL_WARN("svl.items", "Parsing error: " << nMaxRecords <<
-                 " max possible entries, but " << nCount << " claimed, truncating");
-        nCount = nMaxRecords;
-    }
-
-    for ( sal_uInt16 i = 0; i < nCount; ++i )
-    {
-        // Load Surrogate/Item and resolve Surrogate
-        const SfxPoolItem *pItem =
-                m_pPool->LoadItem( rStream, pRefPool );
-
-        // Did we load an Item or resolve a Surrogate?
-        if ( pItem )
-        {
-            // Find position for Item pointer in the set
-            sal_uInt16 nWhich = pItem->Which();
-            SfxItemArray ppFnd = m_pItems;
-            const sal_uInt16* pPtr = m_pWhichRanges;
-            while ( *pPtr )
-            {
-                // In this Range??
-                if ( *pPtr <= nWhich && nWhich <= *(pPtr+1) )
-                {
-                    // Remember Item pointer in the set
-                    ppFnd += nWhich - *pPtr;
-                    SAL_WARN_IF( *ppFnd, "svl.items", "Item is present twice, with ID/pos " << nWhich);
-                    *ppFnd = pItem;
-                    ++m_nCount;
-                    break;
-                }
-
-                // In the range array and Item array to the next Which range
-                ppFnd += *(pPtr+1) - *pPtr + 1;
-                pPtr += 2;
-            }
-        }
-    }
-}
-
 bool SfxItemSet::operator==(const SfxItemSet &rCmp) const
 {
     return Equals( rCmp, true);
@@ -1586,20 +1465,6 @@ void SfxItemSet::PutDirect(const SfxPoolItem &rItem)
     }
 }
 
-sal_Int32 SfxItemSet::getHash() const
-{
-    return stringify().hashCode();
-}
-
-OString SfxItemSet::stringify() const
-{
-    SvMemoryStream aStream;
-    Store(aStream, true);
-    aStream.Flush();
-    return OString(
-        static_cast<char const *>(aStream.GetData()), aStream.GetEndOfData());
-}
-
 void SfxItemSet::dumpAsXml(xmlTextWriterPtr pWriter) const
 {
     xmlTextWriterStartElement(pWriter, BAD_CAST("SfxItemSet"));
diff --git a/svl/source/items/poolio.cxx b/svl/source/items/poolio.cxx
index 54b6d5e..63a14fb 100644
--- a/svl/source/items/poolio.cxx
+++ b/svl/source/items/poolio.cxx
@@ -58,296 +58,6 @@ void SfxPoolItemArray_Impl::ReHash()
     }
 }
 
-static sal_uInt16 convertSfxItemKindToUInt16(SfxItemKind eKind)
-{
-    switch (eKind)
-    {
-    case SfxItemKind::NONE:
-        return 0;
-    case SfxItemKind::DeleteOnIdle:
-        return 0xfffd;
-    case SfxItemKind::StaticDefault:
-        return 0xfffe;
-    case SfxItemKind::PoolDefault:
-        return 0xffff;
-    default:
-        assert("unknown SfxItemKind");
-        return 0;
-    }
-}
-
-static SfxItemKind convertUInt16ToSfxItemKind(sal_uInt16 nRefCnt)
-{
-    switch (nRefCnt)
-    {
-    case 0:
-        return SfxItemKind::NONE;
-    case 0xfffd:
-        return SfxItemKind::DeleteOnIdle;
-    case 0xfffe:
-        return SfxItemKind::StaticDefault;
-    case 0xffff:
-        return SfxItemKind::PoolDefault;
-    default:
-        assert(false);
-        abort();
-    }
-}
-
-
-/**
- * The SfxItemPool is saved to the specified Stream (together with all its
- * secondary Pools) using its Pool Defaults and pooled Items.
- * The static defaults are not saved.
- * [Fileformat]
- *
- *  ;First, a compatibility header section
- *    Start:      0x1111  SFX_ITEMPOOL_TAG_STARTPOOLS(_4/_5)
- *                sal_uInt8   MAJOR_VER                   ;SfxItemPool version
- *               sal_uInt8   MINOR_VER                   ;"
- *               0xFFFF  SFX_ITEMPOOL_TAG_TRICK4OLD      ;ex. GetVersion()
- *               sal_uInt16  0x0000                      ;Pseudo StyleSheetPool
- *               sal_uInt16  0x0000                      ;Pseudo StyleSheetPool
- *
- *   ;The whole Pool into a record
- *              record  SfxMiniRecod(SFX_ITEMPOOL_REC)
- *
- *   ;Start with a Header for each
- *   Header:     record      SfxMiniRecord(SFX_ITEMPOOL_REC_HEADER)
- *               sal_uInt16          GetVersion()        ;Which-Ranges etc.
- *               String          GetName()               ;Pool name
- *
- *  ;The version map: in order to be able to map WhichIds of new file version
- *    Versions:   record      SfxMultiRecord(SFX_ITEMPOOL_REC_VERSIONS, 0)
- *               sal_uInt16          OldVersion
- *               sal_uInt16          OldStartWhich
- *               sal_uInt16          OldEndWhich
- *               sal_uInt16[]        NewWhich (OldEndWhich-OldStartWhich+1)
- *
- *   ;Now the pooled Items (first the non-SfxSetItems)
- *   Items:      record      SfxMultiRecord(SFX_ITEMPOOL_REC_WHICHIDS, 0)
- *                content         SlotId, 0
- *               sal_uInt16          WhichId
- *               sal_uInt16          pItem->GetVersion()
- *               sal_uInt16          Array-Size
- *               record          SfxMultiRecord(SFX_, 0)
- *               content             Surrogate
- *               sal_uInt16              RefCount
- *               unknown             pItem->Store()
- *
- *   ;Now the set Pool defaults
- *   Defaults:   record      SfxMultiRecord(SFX_ITEMPOOL_REC_DEFAULTS, 0)
- *               content         SlotId, 0
- *               sal_uInt16          WhichId
- *               sal_uInt16          pPoolDef->GetVersion()
- *               unknown         pPoolDef->Store();
- *
- *   ;Hereafter the secondary follows (if present) without compatibility header section
- */
-SvStream &SfxItemPool::Store(SvStream &rStream) const
-{
-    // Find StoreMaster
-    SfxItemPool *pStoreMaster = pImpl->mpMaster != this ? pImpl->mpMaster : nullptr;
-    while ( pStoreMaster && !pStoreMaster->pImpl->bStreaming )
-        pStoreMaster = pStoreMaster->pImpl->mpSecondary;
-
-    // Old header (version of the Pool and content version is 0xffff by default)
-    pImpl->bStreaming = true;
-    if ( !pStoreMaster )
-    {
-        rStream.WriteUInt16( rStream.GetVersion() >= SOFFICE_FILEFORMAT_50
-                ? SFX_ITEMPOOL_TAG_STARTPOOL_5
-                : SFX_ITEMPOOL_TAG_STARTPOOL_4  );
-        rStream.WriteUInt8( SFX_ITEMPOOL_VER_MAJOR ).WriteUInt8( SFX_ITEMPOOL_VER_MINOR );
-        rStream.WriteUInt16( SFX_ITEMPOOL_TAG_TRICK4OLD );
-
-        // Work around SfxStyleSheet bug
-        rStream.WriteUInt16( 0 ); // Version
-        rStream.WriteUInt16( 0 ); // Count (or else 2nd loop breaks)
-    }
-
-    // Every Pool as a whole is a record
-    SfxMiniRecordWriter aPoolRec( &rStream, SFX_ITEMPOOL_REC );
-
-    // Single header (content version and name)
-    {
-        SfxMiniRecordWriter aPoolHeaderRec( &rStream, SFX_ITEMPOOL_REC_HEADER);
-        rStream.WriteUInt16( pImpl->nVersion );
-        writeByteString(rStream, pImpl->aName);
-    }
-
-    // VersionMaps
-    {
-        SfxMultiVarRecordWriter aVerRec( &rStream, SFX_ITEMPOOL_REC_VERSIONMAP );
-        for (std::shared_ptr<SfxPoolVersion_Impl>& pVer : pImpl->aVersions)
-        {
-            aVerRec.NewContent();
-            rStream.WriteUInt16( pVer->_nVer ).WriteUInt16( pVer->_nStart ).WriteUInt16( pVer->_nEnd );
-            sal_uInt16 nCount = pVer->_nEnd - pVer->_nStart + 1;
-            sal_uInt16 nNewWhich = 0;
-            for ( sal_uInt16 n = 0; n < nCount; ++n )
-            {
-                nNewWhich = pVer->_pMap[n];
-                rStream.WriteUInt16( nNewWhich );
-            }
-
-            // Workaround for bug in SetVersionMap 312
-            if ( SOFFICE_FILEFORMAT_31 == pImpl->mnFileFormatVersion )
-                rStream.WriteUInt16( nNewWhich+1 );
-        }
-    }
-
-    // Pooled Items
-    {
-        SfxMultiMixRecordWriter aWhichIdsRec( &rStream, SFX_ITEMPOOL_REC_WHICHIDS );
-
-        // First write the atomic Items and then write the Sets (important when loading)
-        for (int ft = 0 ; ft < 2 && !rStream.GetError(); ft++)
-        {
-            pImpl->bInSetItem = ft != 0;
-
-            std::vector<SfxPoolItemArray_Impl*>::const_iterator itrArr = pImpl->maPoolItems.begin();
-            std::vector<SfxPoolItem*> & rStaticDefaults = *pImpl->mpStaticDefaults;
-            const sal_uInt16 nSize = GetSize_Impl();
-            for ( size_t i = 0; i < nSize && !rStream.GetError(); ++i, ++itrArr )
-            {
-                // Get version of the Item
-                sal_uInt16 nItemVersion = rStaticDefaults[i]->GetVersion( pImpl->mnFileFormatVersion );
-                if ( USHRT_MAX == nItemVersion )
-                    // => Was not present in the version that was supposed to be exported
-                    continue;
-
-                // ! Poolable is not even saved in the Pool
-                // And itemsets/plain-items depending on the round
-                if ( *itrArr && IsItemPoolable(*rStaticDefaults[i]) &&
-                     pImpl->bInSetItem == (dynamic_cast< const SfxSetItem* >(rStaticDefaults[i]) != nullptr) )
-                {
-                    // Own signature, global WhichId and ItemVersion
-                    sal_uInt16 nSlotId = GetSlotId( rStaticDefaults[i]->Which(), false );
-                    aWhichIdsRec.NewContent(nSlotId, 0);
-                    rStream.WriteUInt16( rStaticDefaults[i]->Which() );
-                    rStream.WriteUInt16( nItemVersion );
-                    const sal_uInt32 nCount = ::std::min<size_t>( (*itrArr)->size(), SAL_MAX_UINT32 );
-                    DBG_ASSERT(nCount, "ItemArr is empty");
-                    rStream.WriteUInt32( nCount );
-
-                    // Write Items
-                    SfxMultiMixRecordWriter aItemsRec( &rStream, SFX_ITEMPOOL_REC_ITEMS );
-                    for ( size_t j = 0; j < nCount; ++j )
-                    {
-                        // Get Item
-                        const SfxPoolItem *pItem = (*itrArr)->operator[](j);
-                        if ( pItem && pItem->GetRefCount() ) //! See other MI-REF
-                        {
-                            aItemsRec.NewContent((sal_uInt16)j, 'X' );
-
-                            if ( pItem->GetRefCount() == SFX_ITEMS_SPECIAL )
-                                rStream.WriteUInt16( convertSfxItemKindToUInt16(pItem->GetKind()) );
-                            else
-                            {
-                                if( pItem->GetRefCount() > SFX_ITEMS_OLD_MAXREF )
-                                {
-                                    assert(!"refcount does not fit into 16-bits");
-                                    rStream.SetError( ERRCODE_IO_NOTSTORABLEINBINARYFORMAT );
-                                }
-                                else
-                                    rStream.WriteUInt16( pItem->GetRefCount() );
-                            }
-
-                            if ( !rStream.GetError() )
-                                pItem->Store(rStream, nItemVersion);
-                            else
-                                break;
-                        }
-                    }
-                }
-            }
-        }
-
-        pImpl->bInSetItem = false;
-    }
-
-    // Save the set Defaults (PoolDefaults)
-    if ( !rStream.GetError() )
-    {
-        SfxMultiMixRecordWriter aDefsRec( &rStream, SFX_ITEMPOOL_REC_DEFAULTS );
-        for (const SfxPoolItem* pDefaultItem : pImpl->maPoolDefaults)
-        {
-            if ( pDefaultItem )
-            {
-                // Get version
-                sal_uInt16 nItemVersion = pDefaultItem->GetVersion( pImpl->mnFileFormatVersion );
-                if ( USHRT_MAX == nItemVersion )
-                    // => Was not present in the version yet
-                    continue;
-
-                // Own signature, global signature, version
-                sal_uInt16 nSlotId = GetSlotId( pDefaultItem->Which(), false );
-                aDefsRec.NewContent( nSlotId, 0 );
-                rStream.WriteUInt16( pDefaultItem->Which() );
-                rStream.WriteUInt16( nItemVersion );
-
-                // Item
-                pDefaultItem->Store( rStream, nItemVersion );
-            }
-        }
-    }
-
-    // Write out additional Pools
-    aPoolRec.Close();
-    if ( !rStream.GetError() && pImpl->mpSecondary )
-        pImpl->mpSecondary->Store( rStream );
-
-    pImpl->bStreaming = false;
-    return rStream;
-}
-
-/**
- * If the SfxItemPool was loaded with 'bRefCounts' == sal_False, we need
- * to finish the loading of the document contents with a call of this method.
- * In any other case calling this function has no meaning.
- *
- * When loading without RefCounts, they are actually set to 1 so that
- * SfxPoolItems that are needed during and after loading are not deleted.
- * This method resets the RefCount and also removes all items that are not
- * needed anymore.
- *
- * @see SfxItemPool::Load()
-*/
-void SfxItemPool::LoadCompleted()
-{
-    // Did we load without RefCounts?
-    if ( pImpl->nInitRefCount > 1 )
-    {
-        // Iterate over all Which values
-        for (auto& rPoolItemArrayPtr : pImpl->maPoolItems)
-        {
-            // Is there an item with the Which value present at all?
-            if (rPoolItemArrayPtr)
-            {
-                // Iterate over all items with this WhichId
-                for (auto& rItemPtr : *rPoolItemArrayPtr)
-                {
-                    if (rItemPtr)
-                    {
-                        if (!ReleaseRef(*rItemPtr))
-                            DELETEZ(rItemPtr);
-                    }
-                }
-                // don't clear array, fill free list and clear pointer map
-                rPoolItemArrayPtr->ReHash();
-            }
-        }
-
-        // from now on normal initial ref count
-        pImpl->nInitRefCount = 1;
-    }
-
-    // notify secondary pool
-    if ( pImpl->mpSecondary )
-        pImpl->mpSecondary->LoadCompleted();
-}
-
 sal_uInt16 SfxItemPool::GetFirstWhich() const
 {
     return pImpl->mnStart;
@@ -363,363 +73,6 @@ bool SfxItemPool::IsInRange( sal_uInt16 nWhich ) const
     return nWhich >= pImpl->mnStart && nWhich <= pImpl->mnEnd;
 }
 
-// This had to be moved to a method of its own to keep Solaris GCC happy:
-void SfxItemPool_Impl::readTheItems (
-    SvStream & rStream, sal_uInt32 nItemCount, sal_uInt16 nVer,
-    SfxPoolItem const * pDefItem, SfxPoolItemArray_Impl ** ppArr)
-{
-    SfxMultiRecordReader aItemsRec( &rStream, SFX_ITEMPOOL_REC_ITEMS );
-
-    SfxPoolItemArray_Impl *pNewArr = new SfxPoolItemArray_Impl();
-    SfxPoolItem *pItem = nullptr;
-
-    sal_uLong n, nLastSurrogate = sal_uLong(-1);
-    while (aItemsRec.GetContent())
-    {
-        // Get next surrogate
-        sal_uInt16 nSurrogate = aItemsRec.GetContentTag();
-        DBG_ASSERT( aItemsRec.GetContentVersion() == 'X',
-                    "not an item content" );
-
-        // Fill up missing ones
-        // coverity[tainted_data] - ignore this, though we should finally kill off this format
-        for ( pItem = nullptr, n = nLastSurrogate+1; n < nSurrogate; ++n )
-            pNewArr->push_back( pItem );
-        nLastSurrogate = nSurrogate;
-
-        // Load RefCount and Item
-        sal_uInt16 nRef(0);
-        rStream.ReadUInt16( nRef );
-
-        pItem = pDefItem->Create(rStream, nVer);
-        pNewArr->push_back( pItem );
-
-        if ( !mbPersistentRefCounts )
-            // Hold onto it until SfxItemPool::LoadCompleted()
-            SfxItemPool::AddRef(*pItem);
-        else
-        {
-            if ( nRef > SFX_ITEMS_OLD_MAXREF )
-                SfxItemPool::SetKind(*pItem, convertUInt16ToSfxItemKind(nRef));
-            else
-                SfxItemPool::AddRef(*pItem, nRef);
-        }
-    }
-
-    // Fill up missing ones
-    for ( pItem = nullptr, n = nLastSurrogate+1; n < nItemCount; ++n )
-        pNewArr->push_back( pItem );
-
-    SfxPoolItemArray_Impl *pOldArr = *ppArr;
-    *ppArr = pNewArr;
-
-    // Remember items that are already in the pool
-    bool bEmpty = true;
-    if ( nullptr != pOldArr )
-        for ( n = 0; bEmpty && n < pOldArr->size(); ++n )
-            bEmpty = pOldArr->operator[](n) == nullptr;
-    SAL_WARN_IF( !bEmpty, "svl.items", "loading non-empty pool" );
-    if ( !bEmpty )
-    {
-        // See if there's a new one for all old ones
-        for ( size_t nOld = 0; nOld < pOldArr->size(); ++nOld )
-        {
-            SfxPoolItem *pOldItem = (*pOldArr)[nOld];
-            if ( pOldItem )
-            {
-                sal_uInt32 nFree = SAL_MAX_UINT32;
-                bool bFound = false;
-                for ( size_t nNew = (*ppArr)->size(); nNew--; )
-                {
-                    // Loaded Item
-                    SfxPoolItem *&rpNewItem =
-                        (*ppArr)->operator[](nNew);
-
-                    // Unused surrogate?
-                    if ( !rpNewItem )
-                        nFree = nNew;
-
-                    // Found it?
-                    else if ( *rpNewItem == *pOldItem )
-                    {
-                        // Reuse
-                        SfxItemPool::AddRef( *pOldItem, rpNewItem->GetRefCount() );
-                        SfxItemPool::ClearRefCount( *rpNewItem );
-                        delete rpNewItem;
-                        rpNewItem = pOldItem;
-                        bFound = true;
-                        break;
-                    }
-                }
-
-                // Take over the ones that were previously present, but had not been loaded
-                if ( !bFound )
-                {
-                    if ( nFree != SAL_MAX_UINT32 )
-                        (*ppArr)->operator[](nFree) = pOldItem;
-                    else
-                        (*ppArr)->push_back( pOldItem );
-                }
-            }
-        }
-    }
-    delete pOldArr;
-
-    (*ppArr)->ReHash(); // paranoid
-}
-
-SvStream &SfxItemPool::Load(SvStream &rStream)
-{
-    DBG_ASSERT(pImpl->mpStaticDefaults, "No DefaultArray");
-
-    // Protect items by increasing ref count
-    if ( !pImpl->mbPersistentRefCounts )
-    {
-
-        // Iterate over all Which values
-        for(auto const& rArrayPtr : pImpl->maPoolItems)
-        {
-            // Is there an Item with that Which value present at all?
-            if (rArrayPtr)
-            {
-                for (auto const& rItemPtr : *rArrayPtr)
-                    if (rItemPtr)
-                    {
-                        SAL_INFO( "svl.items", "loading non-empty ItemPool" );
-                        AddRef(*rItemPtr);
-                    }
-            }
-        }
-
-        // During loading (until LoadCompleted()) protect all items
-        pImpl->nInitRefCount = 2;
-    }
-
-    // Find LoadMaster
-    SfxItemPool *pLoadMaster = pImpl->mpMaster != this ? pImpl->mpMaster : nullptr;
-    while ( pLoadMaster && !pLoadMaster->pImpl->bStreaming )
-        pLoadMaster = pLoadMaster->pImpl->mpSecondary;
-
-    // Read whole Header
-    pImpl->bStreaming = true;
-    if ( !pLoadMaster )
-    {
-        // Load format version
-        sal_uInt16 nFileTag;
-        rStream.ReadUInt16( nFileTag );
-        if ( SFX_ITEMPOOL_TAG_STARTPOOL_5 != nFileTag && SFX_ITEMPOOL_TAG_STARTPOOL_4 != nFileTag )
-        {
-            OSL_FAIL( "SFX_ITEMPOOL_TAG_STARTPOOL_5" ); /*! s.u. */
-            /*! Set error code and evaluate! */
-            rStream.SetError(SVSTREAM_FILEFORMAT_ERROR);
-            pImpl->bStreaming = false;
-            return rStream;
-        }
-
-        rStream.ReadUChar( pImpl->nMajorVer ).ReadUChar( pImpl->nMinorVer );
-
-        // Take over format version to MasterPool
-        pImpl->mpMaster->pImpl->nMajorVer = pImpl->nMajorVer;
-        pImpl->mpMaster->pImpl->nMinorVer = pImpl->nMinorVer;
-
-        // Unknown Format
-        if (pImpl->nMajorVer < 2 || pImpl->nMajorVer > SFX_ITEMPOOL_VER_MAJOR)
-        {
-            rStream.SetError(SVSTREAM_FILEFORMAT_ERROR);
-            pImpl->bStreaming = false;
-            return rStream;
-        }
-
-        // Trick for version 1.2: skip data
-        sal_uInt16 nFileTag2;
-        rStream.ReadUInt16( nFileTag2 );
-        if ( SFX_ITEMPOOL_TAG_TRICK4OLD != nFileTag2 )
-        {
-            OSL_FAIL( "SFX_ITEMPOOL_TAG_TRICK4OLD" ); /*! s.u. */
-            /*! Set error code and evaluate! */
-            rStream.SetError(SVSTREAM_FILEFORMAT_ERROR);
-            pImpl->bStreaming = false;
-            return rStream;
-        }
-
-        rStream.SeekRel( 4 ); // Hack: Skip data due to SfxStyleSheetPool bug
-    }
-
-    // New record-oriented format
-    SfxMiniRecordReader aPoolRec( &rStream, SFX_ITEMPOOL_REC );
-    if ( rStream.GetError() )
-    {
-        pImpl->bStreaming = false;
-        return rStream;
-    }
-
-    // Single header
-    OUString aExternName;
-    {
-        // Find HeaderRecord
-        SfxMiniRecordReader aPoolHeaderRec( &rStream, SFX_ITEMPOOL_REC_HEADER );
-        if ( rStream.GetError() )
-        {
-            pImpl->bStreaming = false;
-            return rStream;
-        }
-
-        // Read Header
-        rStream.ReadUInt16( pImpl->nLoadingVersion );
-        aExternName = readByteString(rStream);
-        bool bOwnPool = aExternName == pImpl->aName;
-
-        //! As long as we cannot read foreign Pools
-        if ( !bOwnPool )
-        {
-            rStream.SetError(SVSTREAM_FILEFORMAT_ERROR);
-            aPoolRec.Skip();
-            pImpl->bStreaming = false;
-            return rStream;
-        }
-    }
-
-    // Version maps
-    {
-        SfxMultiRecordReader aVerRec( &rStream, SFX_ITEMPOOL_REC_VERSIONMAP );
-        if ( rStream.GetError() )
-        {
-            pImpl->bStreaming = false;
-            return rStream;
-        }
-
-        // Version maps einlesen
-        sal_uInt16 nOwnVersion = pImpl->nVersion;
-        for ( sal_uInt16 nVerNo = 0; aVerRec.GetContent(); ++nVerNo )
-        {
-            // Read header for single versions
-            sal_uInt16 nVersion(0), nHStart(0), nHEnd(0);
-            rStream.ReadUInt16( nVersion ).ReadUInt16( nHStart ).ReadUInt16( nHEnd );
-            sal_uInt16 nCount = nHEnd - nHStart + 1;
-
-            // Is new version is known?
-            if ( nVerNo >= pImpl->aVersions.size() )
-            {
-                // Add new Version
-                const size_t nMaxRecords = rStream.remainingSize() / sizeof(sal_uInt16);
-                if (nCount > nMaxRecords)
-                {
-                    SAL_WARN("svl.items", "Parsing error: " << nMaxRecords <<
-                             " max possible entries, but " << nCount << " claimed, truncating");
-                    nCount = nMaxRecords;
-                }
-                sal_uInt16 *pMap = new sal_uInt16[nCount]{};
-                for ( sal_uInt16 n = 0; n < nCount; ++n )
-                    rStream.ReadUInt16( pMap[n] );
-                SetVersionMap( nVersion, nHStart, nHEnd, pMap );
-            }
-        }
-        pImpl->nVersion = nOwnVersion;
-    }
-
-    // Load Items
-    bool bSecondaryLoaded = false;
-    long nSecondaryEnd = 0;
-    {
-        SfxMultiRecordReader aWhichIdsRec( &rStream, SFX_ITEMPOOL_REC_WHICHIDS);
-        while ( aWhichIdsRec.GetContent() )
-        {
-            // Get SlotId, WhichId and Item version
-            sal_uInt32 nCount(0);
-            sal_uInt16 nVersion(0), nWhich(0);
-            //!sal_uInt16 nSlotId = aWhichIdsRec.GetContentTag();
-            rStream.ReadUInt16( nWhich );
-            if ( pImpl->nLoadingVersion != pImpl->nVersion )
-                // Move WhichId from file version to Pool version
-                nWhich = GetNewWhich( nWhich );
-
-            // Unknown Item from newer version
-            if ( !IsInRange(nWhich) )
-                continue;
-
-            rStream.ReadUInt16( nVersion );
-            rStream.ReadUInt32( nCount );
-            //!SFX_ASSERTWARNING( !nSlotId || !HasMap() ||
-            //!         ( nSlotId == GetSlotId( nWhich, sal_False ) ) ||
-            //!         !GetSlotId( nWhich, sal_False ),
-            //!         nWhich, "Slot/Which mismatch" );
-
-            sal_uInt16 nIndex = GetIndex_Impl(nWhich);
-            SfxPoolItemArray_Impl **ppArr = &pImpl->maPoolItems[0] + nIndex;
-
-            // SfxSetItems could contain Items from secondary Pools
-            SfxPoolItem *pDefItem = (*pImpl->mpStaticDefaults)[nIndex];
-            pImpl->bInSetItem = dynamic_cast<const SfxSetItem*>( pDefItem ) !=  nullptr;
-            if ( !bSecondaryLoaded && pImpl->mpSecondary && pImpl->bInSetItem )
-            {
-                // Seek to end of own Pool
-                sal_uLong nLastPos = rStream.Tell();
-                aPoolRec.Skip();
-
-                // Read secondary Pool
-                pImpl->mpSecondary->Load( rStream );
-                bSecondaryLoaded = true;
-                nSecondaryEnd = rStream.Tell();
-
-                // Back to our own Items
-                rStream.Seek(nLastPos);
-            }
-
-            // Read Items
-            pImpl->readTheItems(rStream, nCount, nVersion, pDefItem, ppArr);
-
-            pImpl->bInSetItem = false;
-        }
-    }
-
-    // Read Pool defaults
-    {
-        SfxMultiRecordReader aDefsRec( &rStream, SFX_ITEMPOOL_REC_DEFAULTS );
-
-        while ( aDefsRec.GetContent() )
-        {
-            // Get SlotId, WhichId and Item versions
-            sal_uInt16 nVersion(0), nWhich(0);
-            //!sal_uInt16 nSlotId = aDefsRec.GetContentTag();
-            rStream.ReadUInt16( nWhich );
-            if ( pImpl->nLoadingVersion != pImpl->nVersion )
-                // Move WhichId from file version to Pool version
-                nWhich = GetNewWhich( nWhich );
-
-            // Unknown Item from newer version
-            if ( !IsInRange(nWhich) )
-                continue;
-
-            rStream.ReadUInt16( nVersion );
-            //!SFX_ASSERTWARNING( !HasMap() || ( nSlotId == GetSlotId( nWhich, sal_False ) ),
-            //!         nWhich, "Slot/Which mismatch" );
-
-            // Load PoolDefaultItem
-            sal_uInt16 nIndex = GetIndex_Impl(nWhich);
-            SfxPoolItem *pItem = (*pImpl->mpStaticDefaults)[ nIndex ]->Create( rStream, nVersion );
-            pItem->SetKind( SfxItemKind::PoolDefault );
-            pImpl->maPoolDefaults[nIndex] = pItem;
-        }
-    }
-
-    // Load secondary Pool if needed
-    aPoolRec.Skip();
-    if ( pImpl->mpSecondary )
-    {
-        if ( !bSecondaryLoaded )
-            pImpl->mpSecondary->Load( rStream );
-        else
-            rStream.Seek( nSecondaryEnd );
-    }
-
-    // If not own Pool, then no name
-    if ( aExternName != pImpl->aName )
-        (pImpl->aName).clear();
-
-    pImpl->bStreaming = false;
-    return rStream;
-};
-
 sal_uInt16 SfxItemPool::GetIndex_Impl(sal_uInt16 nWhich) const
 {
     if (nWhich < pImpl->mnStart || nWhich > pImpl->mnEnd)
@@ -735,152 +88,6 @@ sal_uInt16 SfxItemPool::GetSize_Impl() const
     return pImpl->mnEnd - pImpl->mnStart + 1;
 }
 
-/**
- * Loads surrogate from 'rStream' and returns the corresponding SfxPoolItem
- * from the rRefPool.
- * If the surrogate contained within the stream == SFX_ITEMS_DIRECT
- * (!poolable), we return 0 and the Item is to be loaded directly
- * from the stream.
- * We also return 0 for 0xfffffff0 (SFX_ITEMS_NULL) and rWhich is set to 0,
- * making the Items unavailable.
- *
- * Apart from that we also take into account whether the Pool is loaded without
- * RefCounts, if we reload from a new Pool (&rRefPool != this) or if we're
- * building from a differently constructed Pool.
- *
- * If we load from a differently constructed Pool and the 'nSlotId' cannot be
- * mapped to a WhichId of this Pool, we also return 0.
- *
- * Preconditions:   - Pool must be loaded
- *                  - LoadCompleted must not have been called yet
- *                  - 'rStream' is at the position at which a surrogate
- *                    for an Item with the SlotId 'nSlotId', the WhichId
- *                    'rWhichId' was saved with StoreSurrogate
- *
- * Postconditions:  - 'rStream' is at the same position as after StoreSurrogate
- *                    had finished saving
- *                  - If we were able to load an Item, it's now in this
- *                    SfxItemPool
- *                  - 'rWhichId' now contains the mapped WhichId
- *
- * Runtime: Depth of the traget secondary Pool * 10 + 10
- *
- * @see SfxItemPool::StoreSurrogate(SvStream&,const SfxPoolItem &)const
-*/
-const SfxPoolItem* SfxItemPool::LoadSurrogate
-(
-    SvStream&           rStream,    // Stream before a surrogate
-    sal_uInt16&         rWhich,     // WhichId of the SfxPoolItem that is to be loaded
-    sal_uInt16          nSlotId,    // SlotId of the SfxPoolItem that is to be loaded
-    const SfxItemPool*  pRefPool    // SfxItemPool in which the surrogate is valid
-)
-{
-    // Read the first surrogate
-    sal_uInt32 nSurrogat(0);
-    rStream.ReadUInt32( nSurrogat );
-
-    // Is item stored directly?
-    if ( SFX_ITEMS_DIRECT == nSurrogat )
-        return nullptr;
-
-    // Item does not exist?
-    if ( SFX_ITEMS_NULL == nSurrogat )
-    {
-        rWhich = 0;
-        return nullptr;
-    }
-
-    // If the Pool in the stream has the same structure, the surrogate
-    // can be resolved in any case
-    if ( !pRefPool )
-        pRefPool = this;
-
-    bool bResolvable = !pRefPool->GetName().isEmpty();
-    if ( !bResolvable )
-    {
-        // If the pool in the stream has a different structure, the SlotId
-        // from the stream must be mappable to a WhichId
-        sal_uInt16 nMappedWhich = nSlotId ? GetWhich(nSlotId) : 0;
-        if ( IsWhich(nMappedWhich) )
-        {
-            // Mapped SlotId can be taken over
-            rWhich = nMappedWhich;
-            bResolvable = true;
-        }
-    }
-
-    // Can the surrogate be resolved?
-    if ( bResolvable )
-    {
-        const SfxPoolItem *pItem = nullptr;
-        for ( SfxItemPool *pTarget = this; pTarget; pTarget = pTarget->pImpl->mpSecondary )
-        {
-            // Found the right (Range-)Pool?
-            if ( pTarget->IsInRange(rWhich) )
-            {
-                sal_uInt16 nIndex = pTarget->GetIndex_Impl(rWhich);
-                // Default attribute?
-                if ( SFX_ITEMS_DEFAULT == nSurrogat )
-                    return (*pTarget->pImpl->mpStaticDefaults)[ nIndex ];
-
-                SfxPoolItemArray_Impl* pItemArr = pTarget->pImpl->maPoolItems[nIndex];
-                pItem = pItemArr && nSurrogat < pItemArr->size()
-                            ? (*pItemArr)[nSurrogat]
-                            : nullptr;
-                if ( !pItem )
-                {
-                    OSL_FAIL( "can't resolve surrogate" );
-                    rWhich = 0; // Just to be sure; for the right StreamPos
-                    return nullptr;
-                }
-
-                // Reload from RefPool?
-                if ( pRefPool != pImpl->mpMaster )
-                    return &pTarget->Put( *pItem );
-
-                // References have NOT been loaded together with the pool?
-                if ( !pTarget->pImpl->mbPersistentRefCounts )
-                    AddRef( *pItem );
-                else
-                    return pItem;
-
-                return pItem;
-            }
-        }
-
-        SAL_WARN("svl.items", "can't resolve Which-Id in LoadSurrogate, with ID/pos " << rWhich );
-    }
-
-    return nullptr;
-}
-
-
-/**
- * Saves a surrogate for '*pItem' in 'rStream'
- *
- * @returns sal_True: a real surrogates has been saved
- *                    SFX_ITEMS_NULL for 'pItem==0', SfxItemKind::StaticDefault
- *                    and SfxItemKind::PoolDefault are 'real' surrogates
- *
- * @returns sal_False: a dummy surrogate (SFX_ITEMS_DIRECT) has been saved;
- *                     the actual Item needs to be saved right after it on
- *                     its own
-*/
-bool SfxItemPool::StoreSurrogate ( SvStream& rStream, const SfxPoolItem*  pItem) const
-{
-    if ( pItem )
-    {
-        bool bRealSurrogate = IsItemPoolable(*pItem);
-        rStream.WriteUInt32( bRealSurrogate
-                        ? GetSurrogate( pItem )
-                        : SFX_ITEMS_DIRECT  );
-        return bRealSurrogate;
-    }
-
-    rStream.WriteUInt32( SFX_ITEMS_NULL );
-    return true;
-}
-
 
 sal_uInt32 SfxItemPool::GetSurrogate(const SfxPoolItem *pItem) const
 {
@@ -914,80 +121,6 @@ sal_uInt32 SfxItemPool::GetSurrogate(const SfxPoolItem *pItem) const
 
 
 /**
- * This method allows for the creation of new and incompatible WhichId
- * Ranges or distributions. Pools that were saved with old versions
- * are mapped using the provided conversion table until the current
- * version has been reached. Newer pools can be loaded, but will lose
- * newer attributes, because the map is saved in conjunction with the pool.
- *
- *  Precondition:   Pool must not be loaded yet
- *  Postcondition:  WhichIds from older versions can be mapped to version 'nVer'
- *  Runtime:        1.5 * new + 10
- *
- *  For newer WhichRanges (nStart,nEnd) it must hold that older WhichRanges
- *  (nOldStart,nOldEnd) are completely contained in the newer WhichRange.
- *  It is valid to extend the WhichRange to both sides; also by inserting
- *  WhichIds. Moving WhichIds is not permitted.
- *  This method should only be called in or right after the ctor.
- *
- *  The array must be static, because it's not copied and reused in the
- *  copy-ctor of the SfxItemPool
- *
- *  Example usage:
- *  Originally (version 0) the pool had the following WhichIds:
- *
- *     1:A, 2:B, 3:C, 4:D
- *
- *  A newer version (version 1) is now supposed to contain two new Ids
- *  X and Y between B and C, looking like this:
- *
- *      1:A, 2:B, 3:X, 4:Y, 5:C, 6:D
- *
- *  We see that the Ids 3 and 4 have changed. For the new version, we
- *  would need to set the following in the new Pool:
- *
- *      static sal_uInt16 nVersion1Map = { 1, 2, 5, 6 };
- *      pPool->SetVersionMap( 1, 1, 4, &nVersion1Map );
- *
- *  @see SfxItemPool::IsLoadingVersionCurrent() const
- *  @see SfxItemPool::GetNewWhich(sal_uInt16)
- *  @see SfxItemPool::GetVersion() const
- */
-void SfxItemPool::SetVersionMap
-(
-    sal_uInt16  nVer,               // New version number
-    sal_uInt16  nOldStart,          // Old first WhichId
-    sal_uInt16  nOldEnd,            // Old last WhichId
-    const sal_uInt16* pOldWhichIdTab /* Array containing the structure of the WhichIds
-                                        of the previous version, in which the new
-                                        corresponding new WhichId is located */
-)
-{
-    // Create new map entry to insert
-    const SfxPoolVersion_ImplPtr pVerMap = std::make_shared<SfxPoolVersion_Impl>(
-                nVer, nOldStart, nOldEnd, pOldWhichIdTab );
-    pImpl->aVersions.push_back( pVerMap );
-
-    DBG_ASSERT( nVer > pImpl->nVersion, "Versions not sorted" );
-    pImpl->nVersion = nVer;
-
-    // Adapt version range
-    for ( sal_uInt16 n = 0; n < nOldEnd-nOldStart+1; ++n )
-    {
-        sal_uInt16 nWhich = pOldWhichIdTab[n];
-        if ( nWhich < pImpl->nVerStart )
-        {
-            if ( !nWhich )
-                nWhich = 0;
-            pImpl->nVerStart = nWhich;
-        }
-        else if ( nWhich > pImpl->nVerEnd )
-            pImpl->nVerEnd = nWhich;
-    }
-}
-
-
-/**
  * This method converts WhichIds from a file format to the version of the
  * current pool.
  * If the file format is older, the conversion tables (set by the pool developer
@@ -1004,7 +137,6 @@ void SfxItemPool::SetVersionMap
  *                 linear(Difference of the old and newer version)
  *
  * @see SfxItemPool::IsLoadingVersionCurrent() const
- * @see SfxItemPool::SetVersionMap(sal_uInt16,sal_uInt16,sal_uInt16,sal_uInt16*)
  * @see SfxItemPool::GetVersion() const
  */
 sal_uInt16 SfxItemPool::GetNewWhich
@@ -1012,236 +144,10 @@ sal_uInt16 SfxItemPool::GetNewWhich
     sal_uInt16  nFileWhich // The WhichId loaded from the stream
 )   const
 {
-    // Determine (secondary) Pool
-    if ( !IsInVersionsRange(nFileWhich) )
-    {
-        if ( pImpl->mpSecondary )
-            return pImpl->mpSecondary->GetNewWhich( nFileWhich );
-        SAL_WARN( "svl.items", "unknown which in GetNewWhich(), with ID/pos " << nFileWhich);
-    }
-
-    // Newer/the same/older version?
-    short nDiff = (short)pImpl->nLoadingVersion - (short)pImpl->nVersion;
-
-    // WhichId of a newer version?
-    if ( nDiff > 0 )
-    {
-        // Map step by step from the top version down to the file version
-        for ( size_t nMap = pImpl->aVersions.size(); nMap > 0; --nMap )
-        {
-            SfxPoolVersion_ImplPtr pVerInfo = pImpl->aVersions[nMap-1];
-            if ( pVerInfo->_nVer > pImpl->nVersion )
-            {   sal_uInt16 nOfs;
-                sal_uInt16 nCount = pVerInfo->_nEnd - pVerInfo->_nStart + 1;
-                for ( nOfs = 0;
-                      nOfs <= nCount &&
-                        pVerInfo->_pMap[nOfs] != nFileWhich;
-                      ++nOfs )
-                    continue;
-
-                if ( pVerInfo->_pMap[nOfs] == nFileWhich )
-                    nFileWhich = pVerInfo->_nStart + nOfs;
-                else
-                    return 0;
-            }
-            else
-                break;
-        }
-    }
-
-    // WhichId of a newer version?
-    else if ( nDiff < 0 )
-    {
-        // Map step by step from the top version down to the file version
-        for (std::shared_ptr<SfxPoolVersion_Impl>& pVerInfo : pImpl->aVersions)
-        {
-            if ( pVerInfo->_nVer > pImpl->nLoadingVersion )
-            {
-                if (nFileWhich >= pVerInfo->_nStart &&
-                            nFileWhich <= pVerInfo->_nEnd)
-                {
-                    nFileWhich = pVerInfo->_pMap[nFileWhich - pVerInfo->_nStart];
-                }
-                else
-                {
-                    SAL_WARN("svl.items", "which-id unknown in version");
-                }
-            }
-        }
-    }
-
     // Return original (nDiff==0) or mapped (nDiff!=0) Id
     return nFileWhich;
 }
 
-
-bool SfxItemPool::IsInVersionsRange( sal_uInt16 nWhich ) const
-{
-    return nWhich >= pImpl->nVerStart && nWhich <= pImpl->nVerEnd;
-}
-
-
-/**
- * This method determines whether the loaded Pool version corresponds to the
- * currently loaded Pool structure.
- *
- * Precondition:   Pool is loaded
- * Postcondition:  Unchanged
- * Runtime:        linear(Count of secondary pools)
- *
- * @see SfxItemPool::SetVersionMap(sal_uInt16,sal_uInt16,sal_uInt16,sal_uInt16*)
- * @see SfxItemPool::GetNewWhich(sal_uInt16) const
- * @see SfxItemPool::GetVersion() const
- */
-bool SfxItemPool::IsCurrentVersionLoading() const
-{
-    return ( pImpl->nVersion == pImpl->nLoadingVersion ) &&
-           ( !pImpl->mpSecondary || pImpl->mpSecondary->IsCurrentVersionLoading() );
-}
-
-
-/**
- * Saves the SfxPoolItem 'rItem' to the SvStream 'rStream':
- * either as a surrogate ('bDirect == false') or directly with
- * 'rItem.Store()'.
- * Non-poolable Items are always saved directly. Items without WhichId and
- * SID-Items as well as Items that were not yet present in the file format
- * version (return false) are not saved.
- *
- * The Item is saved to the Stream in the following manner:
- *   sal_uInt16  rItem.Which()
- *   sal_uInt16  GetSlotId( rItem.Which() ) or 0 if not available
- *   sal_uInt16  GetSurrogate( &rItem ) or SFX_ITEM_DIRECT for '!SFX_ITEM_POOLABLE'
- *
- * Optionally (if 'bDirect == true' or '!rItem.IsPoolable()':
- *   sal_uInt16  rItem.GetVersion()
- *   sal_uLong   Size
- *   Size        rItem.Store()
- *
- *  @see SfxItemPool::LoadItem(SvStream&,bool) const
- */
-bool SfxItemPool::StoreItem( SvStream &rStream, const SfxPoolItem &rItem,
-                                 bool bDirect ) const
-{
-    DBG_ASSERT( !IsInvalidItem(&rItem), "cannot store invalid items" );
-
-    if ( IsSlot( rItem.Which() ) )
-        return false;
-
-    const SfxItemPool *pPool = this;
-    while ( !pPool->IsInRange(rItem.Which()) )
-        if ( nullptr == ( pPool = pPool->pImpl->mpSecondary ) )
-            return false;
-
-    DBG_ASSERT( !pImpl->bInSetItem || dynamic_cast<const SfxSetItem*>( &rItem ) ==  nullptr,
-                "SetItem contains ItemSet with SetItem" );
-
-    sal_uInt16 nSlotId = pPool->GetSlotId( rItem.Which() );
-    sal_uInt16 nItemVersion = rItem.GetVersion(pImpl->mnFileFormatVersion);
-    if ( USHRT_MAX == nItemVersion )
-        return false;
-
-    rStream.WriteUInt16( rItem.Which() ).WriteUInt16( nSlotId );
-    if ( bDirect || !pPool->StoreSurrogate( rStream, &rItem ) )
-    {
-        rStream.WriteUInt16( nItemVersion );
-        rStream.WriteUInt32( 0L ); // Room for length in bytes
-        sal_uLong nIStart = rStream.Tell();
-        rItem.Store(rStream, nItemVersion);
-        sal_uLong nIEnd = rStream.Tell();
-        rStream.Seek( nIStart-4 );
-        rStream.WriteInt32( nIEnd-nIStart );
-        rStream.Seek( nIEnd );
-    }
-
-    return true;
-}
-
-
-/**
- * If pRefPool==-1 => do not put!
- */
-const SfxPoolItem* SfxItemPool::LoadItem( SvStream &rStream,
-                                          const SfxItemPool *pRefPool )
-{
-    sal_uInt16 nWhich(0), nSlot(0); // nSurrogate;
-    rStream.ReadUInt16( nWhich ).ReadUInt16( nSlot );
-
-    bool bDontPut = reinterpret_cast<SfxItemPool*>(-1) == pRefPool;
-    if ( bDontPut || !pRefPool )
-        pRefPool = this;
-
-    // Find right secondary Pool
-    while ( !pRefPool->IsInVersionsRange(nWhich) )
-    {
-        if ( pRefPool->pImpl->mpSecondary )
-            pRefPool = pRefPool->pImpl->mpSecondary;
-        else
-        {
-            // WID not present in this version => skip
-            sal_uInt32 nSurro(0);
-            sal_uInt16 nVersion(0), nLen(0);
-            rStream.ReadUInt32( nSurro );
-            if ( SFX_ITEMS_DIRECT == nSurro )
-            {
-                rStream.ReadUInt16( nVersion ).ReadUInt16( nLen );
-                rStream.SeekRel( nLen );
-            }
-            return nullptr;
-        }
-    }
-
-    // Are we loading a different version?
-    bool bCurVersion = pRefPool->IsCurrentVersionLoading();
-    if ( !bCurVersion )
-        nWhich = pRefPool->GetNewWhich( nWhich ); // Map WhichId to new version
-
-    DBG_ASSERT( !nWhich || !pImpl->bInSetItem ||
-                dynamic_cast<const SfxSetItem*>( (*pRefPool->pImpl->mpStaticDefaults)[pRefPool->GetIndex_Impl(nWhich)] ) == nullptr,
-                "loading SetItem in ItemSet of SetItem" );
-
-    // Are we loading via surrogate?
-    const SfxPoolItem *pItem = nullptr;
-    // WhichId known in this version?
-    if ( nWhich )
-        // Load surrogate and react if none present
-        pItem = LoadSurrogate( rStream, nWhich, nSlot, pRefPool );
-    else
-        // Else skip it
-        rStream.SeekRel( sizeof(sal_uInt16) );
-
-    // Is loaded directly (not via surrogate)?
-    if ( nWhich && !pItem )
-    {
-        // bDirekt or not IsPoolable() => Load Item directly
-        sal_uInt16 nVersion(0);
-        sal_uInt32 nLen(0);
-        rStream.ReadUInt16( nVersion ).ReadUInt32( nLen );
-        sal_uLong nIStart = rStream.Tell();
-
-        // Load Item directly
-        SfxPoolItem *pNewItem =
-                pRefPool->GetDefaultItem(nWhich).Create(rStream, nVersion);
-        if ( bDontPut )
-            pItem = pNewItem;
-        else
-            if ( pNewItem )
-            {
-                pItem = &Put(*pNewItem);
-                delete pNewItem;
-            }
-            else
-                pItem = nullptr;
-        sal_uLong nIEnd = rStream.Tell();
-        DBG_ASSERT( nIEnd <= (nIStart+nLen), "read past end of item" );
-        if ( (nIStart+nLen) != nIEnd )
-            rStream.Seek( nIStart+nLen );
-    }
-
-    return pItem;
-}
-
-
 OUString readByteString(SvStream& rStream)
 {
     return rStream.ReadUniOrByteString(rStream.GetStreamCharSet());
diff --git a/svl/source/items/sitem.cxx b/svl/source/items/sitem.cxx
index d209565..ef50cc1 100644
--- a/svl/source/items/sitem.cxx
+++ b/svl/source/items/sitem.cxx
@@ -72,11 +72,4 @@ bool SfxSetItem::GetPresentation
     return false;
 }
 
-
-SvStream& SfxSetItem::Store(SvStream& rStream, sal_uInt16) const
-{
-    GetItemSet().Store(rStream);
-    return rStream;
-}
-
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/svx/source/items/pageitem.cxx b/svx/source/items/pageitem.cxx
index 0e59f4e..18c4981 100644
--- a/svx/source/items/pageitem.cxx
+++ b/svx/source/items/pageitem.cxx
@@ -229,38 +229,6 @@ bool SvxPageItem::PutValue( const uno::Any& rVal, sal_uInt8 nMemberId )
     return true;
 }
 
-
-SfxPoolItem* SvxPageItem::Create( SvStream& rStream, sal_uInt16 ) const
-{
-    sal_uInt8 eType;
-    bool bLand;
-    sal_uInt16 nUse;
-
-    // UNICODE: rStream >> sStr;
-    OUString sStr = rStream.ReadUniOrByteString( rStream.GetStreamCharSet() );
-
-    rStream.ReadUChar( eType );
-    rStream.ReadCharAsBool( bLand );
-    rStream.ReadUInt16( nUse );
-
-    SvxPageItem* pPage = new SvxPageItem( Which() );
-    pPage->SetDescName( sStr );
-    pPage->SetNumType( (SvxNumType)eType );
-    pPage->SetLandscape( bLand );
-    pPage->SetPageUsage( (SvxPageUsage)nUse );
-    return pPage;
-}
-
-
-SvStream& SvxPageItem::Store( SvStream &rStrm, sal_uInt16 /*nItemVersion*/ ) const
-{
-    // UNICODE: rStrm << aDescName;
-    rStrm.WriteUniOrByteString(aDescName, rStrm.GetStreamCharSet());
-
-    rStrm.WriteUChar( eNumType ).WriteBool( bLandscape ).WriteUInt16( (sal_uInt16)eUse );
-    return rStrm;
-}
-
 // HeaderFooterSet
 SvxSetItem::SvxSetItem( const sal_uInt16 nId, const SfxItemSet& rSet ) :
 
@@ -298,22 +266,5 @@ bool SvxSetItem::GetPresentation
     return false;
 }
 
-SfxPoolItem* SvxSetItem::Create(SvStream &rStrm, sal_uInt16 /*nVersion*/) const
-{
-    SfxItemSet* _pSet = new SfxItemSet( *GetItemSet().GetPool(),
-                                       GetItemSet().GetRanges() );
-
-    _pSet->Load( rStrm );
-
-    return new SvxSetItem( Which(), *_pSet );
-}
-
-SvStream& SvxSetItem::Store(SvStream &rStrm, sal_uInt16 nItemVersion) const
-{
-    GetItemSet().Store( rStrm, nItemVersion );
-
-    return rStrm;
-}
-
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/svx/source/xoutdev/xattr.cxx b/svx/source/xoutdev/xattr.cxx
index c0b1141..0550493 100644
--- a/svx/source/xoutdev/xattr.cxx
+++ b/svx/source/xoutdev/xattr.cxx
@@ -2918,15 +2918,6 @@ SfxPoolItem* XLineAttrSetItem::Clone( SfxItemPool* pPool ) const
     return new XLineAttrSetItem( *this, pPool );
 }
 
-/// create a set item out of a stream
-SfxPoolItem* XLineAttrSetItem::Create( SvStream& rStream, sal_uInt16 /*nVersion*/) const
-{
-    auto pSet2 = o3tl::make_unique<SfxItemSet>( *GetItemSet().GetPool(),
-                                    svl::Items<XATTR_LINE_FIRST, XATTR_LINE_LAST>{});
-    pSet2->Load( rStream );
-    return new XLineAttrSetItem( std::move(pSet2) );
-}
-
 /// fill attribute set item
 XFillAttrSetItem::XFillAttrSetItem( std::unique_ptr<SfxItemSet>&& pItemSet ) :
     SfxSetItem( XATTRSET_FILL, std::move(pItemSet))
@@ -2955,13 +2946,4 @@ SfxPoolItem* XFillAttrSetItem::Clone( SfxItemPool* pPool ) const
     return new XFillAttrSetItem( *this, pPool );
 }
 
-/// create a set item out of a stream
-SfxPoolItem* XFillAttrSetItem::Create( SvStream& rStream, sal_uInt16 /*nVersion*/) const
-{
-    auto pSet2 = o3tl::make_unique<SfxItemSet>( *GetItemSet().GetPool(),
-                                    svl::Items<XATTR_FILL_FIRST, XATTR_FILL_LAST>{});
-    pSet2->Load( rStream );
-    return new XFillAttrSetItem( std::move(pSet2) );
-}
-
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
-- 
2.7.4

